1. 原型链的意义
   1. 拥有其他对象的方法和属性， 
   2. 采用一种地址引用的方式
   3. 好处：降低内存的占有，毕竟复制对象的方法属性需要大量内存
   4. 浏览器的局限：浏览器只分配了少量的内存，原因： 跟浏览器的单线程的原因比较大，如果内存过大，在进行gc垃圾回收的时候会导致时间过长
2. gc垃圾回收
   1. 栈：移动指针直接销毁
   2. 堆
      1. 采用两种方式： 小部分的新生代，和比较大一点的老生代
      2. 新生代划分为对象区域和空闲区域，直接采用标记垃圾，对象区域满了直接将存活的移到空闲区域，然后调换两个区域
         1. JavaScript 引擎采用了对象晋升策略，也就是经过两次垃圾回收依然还存活的对象，会被移动到老生区中。
      3. 主垃圾回收器
         1. 标记-清除， 比较大，所以采用增量标记(单线程回收过多会卡顿)
   3. 总结：无论是主副垃圾回收器的策略都是标记-清除-整理三个大的步骤。另外还有新生代的晋升策略（两次未清除的），大对象直接分配在老生代。
   4. 垃圾回收做的3个工作
      1. 标记活动或非活动
      2. 回收空间
      3. 整理内存


3. 伪类和伪元素
   1. 伪类：：active、:visited等
      1. 伪类用于选择DOM树之外的信息，或是不能用简单选择器进行表示的信息
   2. 伪元素： ::first-child 、::before
      1. 伪元素为DOM树没有定义的虚拟元素


4. picture 元素
   1. picture 元素可以根据屏幕的条件为其中的 img 元素提供不同的源，它的基本用法如下
   ```html
     <picture>
        <source srcset="image-wide.png" media="(min-width: 600px)">
        <img src="image-narrow.png">
     </picture>
   ```
   

5. Vue 双向绑定原理
   1. 采用数据劫持结合订阅-发布模式


6. transition 和 animation
   1. transition 手动触发 一次性
   2. animation 可以自动触发 可以设置触发次数 帧的概念
   

7. webpack
   1. 构建流程
      1. 初始化阶段：
         - 初始化参数：从配置文件、 配置对象、Shell 参数中读取，与默认配置结合得出最终的参数
         - 创建编译器对象：用上一步得到的参数创建 Compiler 对象
         - 初始化编译环境：包括注入内置插件、注册各种模块工厂、初始化 RuleSet 集合、加载配置的插件等
         - 开始编译：执行 compiler 对象的 run 方法
         - 确定入口：根据配置中的 entry 找出所有的入口文件，调用 compilition.addEntry 将入口文件转换为 dependence 对象
      2. 构建阶段：
          - 编译模块(make)：根据 entry 对应的 dependence 创建 module 对象，调用 loader 将模块转译为标准 JS 内容，调用 JS 解释器将内容转换为 AST 对象，从中找出该模块依赖的模块，再 递归 本步骤直到所有入口依赖的文件都经过了本步骤的处理
          - 完成模块编译：上一步递归处理所有能触达到的模块后，得到了每个模块被翻译后的内容以及它们之间的 依赖关系图
      3. 生成阶段：
         - 输出资源(seal)：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会
         - 写入文件系统(emitAssets)：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统

   2. loader作用
   3. plugin作用


8. mvvm
   1. mvc: 实际上是一种解耦的方式，将model也就是数据和view分离，将数据处理放到controller里面
   2. mvvm：在model和view之间多一层view-model将视图和数据绑定，也就是自动实现了controller的部分，除去了用户去操作视图的部分，由框架去完成，类似vue、angular
   3. vue2中的mvvm的实现

9. vue2 vs vue3
   1. 性能提升：创建是来开销（挂载this的方法）
   2. 模板编译到虚拟dom, 做静态分析（静态节点分离到render外面去）
   3. ssr性能的提升

10. vue diff
    1. 四种命中查找：经典的diff算法优化策略
       1. ①新前与旧前
       2. ②新后与旧后
       3. ③新后与旧前（此种发生了，涉及移动节点，那么新前指向的节点，移动的旧后之后）
       4. ④新前与旧后（此种发生了，涉及移动节点，那么新前指向的节点，移动的旧前之前）
       5. 命中一种就不再进行命中判断了
       6. 如果都没有命中，就需要用循环来寻找了。移动到oldStartIdx之前。
