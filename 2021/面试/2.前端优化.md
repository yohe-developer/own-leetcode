

1. 代码层面的优化
   1. 正确的使用vif vshow
   2. 区分watch computed
   3. v-for 加key
   4. 图片懒加载
   5. 路由懒加载
   6. 插件按需加载（第三方库按需加载）
   7. <keep-alive>
   8. 使用字体图标
   
2. 打包优化
   1. splitChunksPlugins
   2. JS分包
   3. 预加载技术（prefetch）
   4. 预渲染（pre-rendering）

前端面试如何说解vue项目性能优化

我个人认为性能优化可以从三个方面来进行，
   1. 一是代码层面的优化
   2. 二是项目打包的优化
   3. 三是项目部署的优化。
代码层面
   4. v-if v-show
   5. computed、watch、methods区分使用场景
   6. 提前处理好数据解决v-if和v-for必须同级的问题
   7. 给v-for循环项加上key提高diff计算速度
   8. 利用v-once处理只会渲染一次的元素或组件 (内部用cache 数组 缓存 vNode)
   9. 提前过滤掉非必须数据，优化data选项中的数据结构(删除后端的多余 字段)
   10. 避免在v-for循环中读取data中数组类型的数据
   11. 图片大小优化和懒加载
   12. 组件库的按需引入
   13. 组件优化
项目打包的优化
   13. 利用import()异步引入组件实现按需引入
   14. 利用externals提取第三方依赖并用CDN引入
   15. 利用SplitChunks插件提取公共js代码和分割js代码


项目部署的优化
   1. 识别gzip压缩是否开启
   2. CompressionPlugin插件压缩，会有缓存，可以相对减少打包时间。

参考：https://zhuanlan.zhihu.com/p/147958620



一个页面安的生命周期无非是
1. 网络请求
    prefetch（可能使用的资源）
    preload（必要资源）
    meta 开启dns预解析和缓存
    降低单个文件的大小
    合并文件，减少请求
    浏览器限制6个tcp， 可以使用其他域名加载资源
    把站点升级到 HTTP2，因为 HTTP2 已经没有每个域名最多维护 6 个 TCP 连接的限制了。

2. 运行交互



关于web 优化

其实现在vuecli的集成度非常的高， 基本配置都是取最优的，基本没有配置过这些。
也就是设置路径、和source-map
和代理服务

其实webpack的优化无非就是
代码分块，按需加载； tree-sharking删除无用的代码
抽取公共代码利用缓存，
图片、js压缩

并且由于webpack的配置复杂，4.0以后默认提供了production的模式， 减少配置负担。


其实在这个硬件性能过剩的时代
	1. 网络加载的资源的速度
	2. 浏览器缓存
	3. 代码优化

比如代码不能在一个周期内执行过长， 也应该采用分片的形式去执行，这也是当前这些框架采用的手段。 或者 大计算采用web  worker 去处理。

网络加载的瓶颈在于两个方面
	1. http 请求的次数， 毕竟浏览器对于同一个域名下有请求限制， 其次tcp的3次连接的耗时。
	2. 资源大小的加载， 追求速度，最好采用服务端去渲染， 毕竟现在的vue 等框架， 全部都是处理成js 。 下载和运行时间都比较长，采用服务端渲染，会直接返回html片段， 减少体积的同时 也降低了 客服端的执行时间

对于网络加载同时可以采用http2.0
	1. 采用多路复用的特性， 减少http请求；http2。0 只会保持一个请求。同时采用二进制流的方式， 同时压缩头部， 极大的提高了效率
	2. 还能主动推送文件个客服端，预先处理html中的其他文件请求。
	3. http1.1  采用的是管道的形式，必须按照请求顺序去处理，然后应答。而http2.0采用流和帧的概念可以分成如干个乱序的发送最后再服务端进行重组，解决了http层面的阻塞。。但是http2.0 采用的是tcp连接， 当其中一个失败 还是会重传，依然很难解决问题。
http3.0 传输层使用了 UDP协议， 解决了 这个阻塞问题（具体我也不台清楚， 是因为UDP是不可靠， 不需要中断重连， 而是在上层协议QUIC中处理？）

